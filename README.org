#+BABEL: :session *clojure-nrepl* :cache yes :results value
#+PROPERTY: header-args :comments link
#+PROPERTY: noweb: yes

* org.msync/lucene-clj [[http://travis-ci.org/jaju/lucene-clj][file:https://secure.travis-ci.org/jaju/lucene-clj.png]]

** What?

A Clojure wrapper for Apache Lucene.

Both in-memory, and on-disk indexes can be used depending on the dataset size.

Note: *UNSTABLE* API. No releases yet.

Inspired by other example wrappers I've come across.
Notably
 - [[https://github.com/federkasten/clucie][Clucie]]
 - [[https://github.com/weavejester/clucy][Clucy]]

*** A note about *this* README.org. 
The code here should always be valid, being written in the literate programming style and /org-tangled/ to the relevant files.


** Dependency
#+BEGIN_SRC clojure
    [org.msync/lucene-clj "0.2.0-SNAPSHOT"]
#+END_SRC
Available via [[https://clojars.org/search?q=lucene-clj][clojars]].


** Why?

The primary use-case is for in-process text search needs for primarily read-only datasets that can be managed on single-instance deployments. Because for multi-instance deployments, keeping modifications of data in sync is an effort. In other words, when you need light-weight text-search support without the hassle of setting up something like Solr.

This is imagined as a light-weight library for cheaply creating search indexes for simple scenarios. Any updates to the index are suggested to be done via create-a-new-index-and-switch approach. The objectives are loosely as follows.

- Stick to _core_ Lucene. No script/language specific dependencies part of the core language, but can be added by users per need.
- Support for _suggestions_ - a feature of Lucene I found quite undocumented, as well as lacking good examples for.
- Up-to-date with the latest Lucene as on date.

I am thankful to the above library authors for their liberal licensing. I've used their ideas/code in places.


** Usage

Note: There's sample data in the repository that we use in our examples. A hand-created sample with fictional and non-fictional characters is [[file:test-resources/sample-data.csv][here]] and one from Kaggle on music albums is [[file:test-resources/albumlist.csv][here]]. These are also used in the tests.

*** Given

Following is code to demonstrate how text can be prepared to be fed into Lucene for indexing. We use two CSV files as our source of /documents/, but the sources could very well be anything, as long as they are converted into maps before being indexed by /lucene-clj/.

A note on the datasets.
- The albums dataset
  - The columns /:Genre/ and /:Subgenre/, are comma-separated values themselves
    - They are pre-processed before feeding to /lucene-clj/
  - The /:Year/, /:Genre/ and /:Subgenre/ fields' texts are not to be tokenized and stemmed, or filtered for stop-words. Hence, they are configured to be analyzed with the /keyword analyzer/.

Below, we consume the files from the resources classpath as set up for this project using Java's IO facilities, and then perform CSV to map conversion for each row.

#+BEGIN_SRC clojure :tangle test/msync/lucene/tests_common.clj :results none
  (ns msync.lucene.tests-common
    (:require [msync.lucene
               [analyzers :as analyzers]]
              [msync.lucene.utils :as utils]
              [clojure.data.csv :as csv]
              [clojure.java.io :as io]
              [clojure.string :as s]))

  (defn- process-csv-column [coll column]
    (assoc coll column
           (map s/trim (s/split (get coll column) #","))))

  (defn process-album-data-row [row]
    (-> row
        (process-csv-column :Genre)
        (process-csv-column :Subgenre)))

  (defonce sample-data (-> "sample-data.csv"
                           io/resource
                           slurp
                           csv/read-csv
                           utils/docs:vecs->maps))

  (def album-data (->> "albumlist.csv"
                           io/resource
                           slurp
                           csv/read-csv
                           utils/docs:vecs->maps
                           (map process-album-data-row)))

  (defonce default-analyzer (analyzers/standard-analyzer))
  (defonce keyword-analyzer (analyzers/keyword-analyzer))

  ;; A per-field analyzer, which composes other kinds of analyzers
  (defonce album-data-analyzer
    (analyzers/per-field-analyzer default-analyzer
                                  {:Year     keyword-analyzer
                                   :Genre    keyword-analyzer
                                   :Subgenre keyword-analyzer}))
#+END_SRC


***  Some simple REPL-runs

As you may expect, this is for your REPLeasure. I've used the /dev/ namespace, which can be found [[file:dev/dev.clj][here]].

**** Preamble
#+BEGIN_SRC clojure :tangle dev/dev.clj :results none
  (ns dev
    (:require [msync.lucene :as lucene]
              [msync.lucene
               [store :as store]
               [document :as ld]
               [tests-common :refer :all]]))
#+END_SRC


**** COMMENT Switch namespace
#+BEGIN_SRC clojure
(in-ns 'dev)
#+END_SRC

#+RESULTS:


**** Create an index
In memory
#+BEGIN_SRC clojure :tangle dev/dev.clj :results none
  (def index (store/store :memory :analyzer album-data-analyzer))
#+END_SRC

Or, on disk
#+BEGIN_SRC clojure :tangle no :results none
  (def index (store/store "/path/to/index/directory" :analyzer album-data-analyzer))
#+END_SRC

Sample album data for reference. The /genre/ and /subgenre/ columns are pre-processed, as mentioned above, and split further.
#+BEGIN_SRC clojure :tangle no :results output code :exports both
(take 3 album-data)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC clojure
({:Number "1",
  :Year "1967",
  :Album "Sgt. Pepper's Lonely Hearts Club Band",
  :Artist "The Beatles",
  :Genre ("Rock"),
  :Subgenre ("Rock & Roll" "Psychedelic Rock")}
 {:Number "2",
  :Year "1966",
  :Album "Pet Sounds",
  :Artist "The Beach Boys",
  :Genre ("Rock"),
  :Subgenre ("Pop Rock" "Psychedelic Rock")}
 {:Number "3",
  :Year "1966",
  :Album "Revolver",
  :Artist "The Beatles",
  :Genre ("Rock"),
  :Subgenre ("Psychedelic Rock" "Pop Rock")})
#+END_SRC


**** Index documents - which are Clojure maps
Documents are Clojure maps. Each /key/ in the map represents one Lucene /Document/ /Field/. The options passed to the `index!` function control behavior in various ways
- /:stored-fields/ - Lucene can index for efficient searching, but to save space, it need not store all the field values. If you want Lucene to also store the contents, pass them as a collection to this argument. The alternative is to use Lucene to index without storing large fields, and 
- /:suggest-fields/ - Fields that are treated specially during indexing, allowing Lucene to create internal structures for quick prefix matching.
- /:context-fn/ - Lucene allows for a list of contexts to associate with the /suggest/ fields, which allow us to filter on them while querying for suggestions.

In the following, we instruct the /index/ function to 
- Store the mentioned fields
- Use the /:Album/ and /:Artist/ fields to index for suggestions
- Use the /:Genre/ field as context. Note that /:Genre/ is itself can be multiple values for each document, and that works fine.
#+BEGIN_SRC clojure :tangle dev/dev.clj :results none
  (lucene/index! index album-data
                 {:stored-fields  [:Number :Year :Album :Artist :Genre :Subgenre]
                  :suggest-fields [:Album :Artist]
                  :context-fn     :Genre})
#+END_SRC


**** Now, we can search
A simple search example, in which we pass a /map/ specifying the field, and the value we are looking for.
The result includes the /:hit/, a /:score/ for that /:hit/, and the /:doc-id/ which is an identifier that Lucene manages. Notice that the result - /:hit/ - is a Lucene /Document/ object.

#+BEGIN_SRC clojure :results output code :tangle dev/dev.clj :exports both
  (lucene/search index {:Year "1979"}
                 {:results-per-page 2})
#+END_SRC

#+RESULTS:
#+BEGIN_SRC clojure
[{:hit
  #object[org.apache.lucene.document.Document 0x74b36b5 "Document<stored,indexed,tokenized,indexOptions=DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS<Number:8> stored,indexed,tokenized,indexOptions=DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS<Year:1979> stored,indexed,tokenized,indexOptions=DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS<Album:London Calling> stored,indexed,tokenized,indexOptions=DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS<Artist:The Clash> stored,indexed,tokenized,indexOptions=DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS<Genre:Rock> stored,indexed,tokenized,indexOptions=DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS<Subgenre:Punk> stored,indexed,tokenized,indexOptions=DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS<Subgenre:New Wave>>"],
  :score 1.6102078,
  :doc-id 7}
 {:hit
  #object[org.apache.lucene.document.Document 0x92da924 "Document<stored,indexed,tokenized,indexOptions=DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS<Number:68> stored,indexed,tokenized,indexOptions=DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS<Year:1979> stored,indexed,tokenized,indexOptions=DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS<Album:Off the Wall> stored,indexed,tokenized,indexOptions=DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS<Artist:Michael Jackson> stored,indexed,tokenized,indexOptions=DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS<Genre:Funk / Soul> stored,indexed,tokenized,indexOptions=DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS<Genre:Pop> stored,indexed,tokenized,indexOptions=DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS<Subgenre:Disco> stored,indexed,tokenized,indexOptions=DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS<Subgenre:Soul> stored,indexed,tokenized,indexOptions=DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS<Subgenre:Ballad>>"],
  :score 1.6102078,
  :doc-id 67}]
#+END_SRC

For convenience, /lucene-clj/ has a function that can be used to convert the Lucene /Document/ into a Clojure map.
#+BEGIN_SRC clojure :results output code :tangle dev/dev.clj :exports both
    (lucene/search index {:Year "1979"}
                   {:results-per-page 2
                    :hit->doc ld/document->map})
#+END_SRC

#+RESULTS:
#+BEGIN_SRC clojure
[{:hit
  {:Number "8",
   :Year "1979",
   :Album "London Calling",
   :Artist "The Clash",
   :Genre "Rock",
   :Subgenre "New Wave"},
  :score 1.6102078,
  :doc-id 7}
 {:hit
  {:Number "68",
   :Year "1979",
   :Album "Off the Wall",
   :Artist "Michael Jackson",
   :Genre "Pop",
   :Subgenre "Ballad"},
  :score 1.6102078,
  :doc-id 67}]
#+END_SRC

Notice though, that the /:Genre/ and /:Subgenre/ fields did not come back as collections. The /document->map/ function isn't smart to identify that, and needs a hint to make that happen.

#+BEGIN_SRC clojure :results output code :tangle dev/dev.clj :exports both
    (lucene/search index {:Year "1979"}
                   {:results-per-page 2
                    :hit->doc #(ld/document->map % :multi-fields [:Genre :Subgenre])})
#+END_SRC

#+RESULTS:
#+BEGIN_SRC clojure
[{:hit
  {:Number "8",
   :Year "1979",
   :Album "London Calling",
   :Artist "The Clash",
   :Genre ["Rock"],
   :Subgenre ["Punk" "New Wave"]},
  :score 1.6102078,
  :doc-id 7}
 {:hit
  {:Number "68",
   :Year "1979",
   :Album "Off the Wall",
   :Artist "Michael Jackson",
   :Genre ["Funk / Soul" "Pop"],
   :Subgenre ["Disco" "Soul" "Ballad"]},
  :score 1.6102078,
  :doc-id 67}]
#+END_SRC


Paginated query results are supported via the /:page/ option. Also, the following example projects a subset of the document fields by passing a modified function as the /:hit->doc/ argument.
#+BEGIN_SRC clojure :results output code :tangle dev/dev.clj :exports both
    (lucene/search index 
                   {:Year "1968"} ;; Map of field-values to search with
                   {:results-per-page 5 ;; Control the number of results returned
                    :page 4             ;; Page number, starting 0 as default
                    :hit->doc         #(-> %
                                           ld/document->map
                                           (select-keys [:Year :Album]))})
#+END_SRC

#+RESULTS:
#+BEGIN_SRC clojure
[{:hit {:Year "1968", :Album "The Drifters' Golden Hits"},
  :score 1.4311604,
  :doc-id 458}]
#+END_SRC


**** Search variations

- Simple search
Searching in a single field, for a single value
#+BEGIN_SRC clojure :tangle no :results no
(lucene/search index {:Year "1967"})
#+END_SRC

- OR Search
Searching in a single field, where _any_ of the values in the /set/ are allowed
#+BEGIN_SRC clojure :tangle no :results output code :exports both
  (lucene/search index {:Year #{"1964" "1965"}}
                 {:results-per-page 3
                  :hit->doc #(-> % ld/document->map (select-keys [:Year :Album]))})
#+END_SRC

#+RESULTS:
#+BEGIN_SRC clojure
[{:hit {:Year "1964", :Album "Meet The Beatles!"},
  :score 2.1420584,
  :doc-id 52}
 {:hit {:Year "1964", :Album "Folk Singer"},
  :score 2.1420584,
  :doc-id 281}
 {:hit {:Year "1964", :Album "A Hard Day's Night"},
  :score 2.1420584,
  :doc-id 306}]
#+END_SRC

- AND Search
When looking for multiple terms in a single field, pass a /vector/.
#+BEGIN_SRC clojure :tangle no :results output code :exports both
(lucene/search index {:Album ["complete" "unbelievable"]} {:hit->doc ld/document->map})
#+END_SRC

#+RESULTS:
#+BEGIN_SRC clojure
[{:hit
  {:Number "254",
   :Year "1966",
   :Album
   "Complete & Unbelievable: The Otis Redding Dictionary of Soul",
   :Artist "Otis Redding",
   :Genre "Funk / Soul",
   :Subgenre "Soul"},
  :score 3.057108,
  :doc-id 253}]
#+END_SRC

Be sure that your queries are semantically right for the dataset. For example, /AND/-ing over two different years will lead to an empty result-set, obviously.
#+BEGIN_SRC clojure :tangle no :results output code :exports both
(lucene/search index {:Year ["1964" "1965"]})
#+END_SRC

#+RESULTS:
#+BEGIN_SRC clojure
[]
#+END_SRC

- Phrase search
Spaces in the query string are inferred to mean a phrase search operation
#+BEGIN_SRC clojure :tangle no :results output code :exports both
  (lucene/search index {:Album "the sun"} {:hit->doc ld/document->map})
#+END_SRC

#+RESULTS:
#+BEGIN_SRC clojure
[{:hit
  {:Number "11",
   :Year "1976",
   :Album "The Sun Sessions",
   :Artist "Elvis Presley",
   :Genre "Rock",
   :Subgenre "Rock & Roll"},
  :score 2.8861985,
  :doc-id 10}
 {:hit
  {:Number "288",
   :Year "1968",
   :Album "Anthem of the Sun",
   :Artist "Grateful Dead",
   :Genre "Rock",
   :Subgenre "Psychedelic Rock"},
  :score 2.544825,
  :doc-id 287}
 {:hit
  {:Number "311",
   :Year "1994",
   :Album "The Sun Records Collection",
   :Artist "Various",
   :Genre "Rock, Funk / Soul, Blues, Pop, Folk, World, & Country",
   :Subgenre "Country Blues, Rock & Roll, Rockabilly"},
  :score 2.544825,
  :doc-id 310}]
#+END_SRC

- Searching across fields

This is an /AND/ operation

#+BEGIN_SRC clojure :tangle no :results output code :exports both
  (lucene/search index {:Album "the sun" :Year "1976"} {:hit->doc ld/document->map})
#+END_SRC

#+RESULTS:
#+BEGIN_SRC clojure
[{:hit
  {:Number "11",
   :Year "1976",
   :Album "The Sun Sessions",
   :Artist "Elvis Presley",
   :Genre "Rock",
   :Subgenre "Rock & Roll"},
  :score 4.56387,
  :doc-id 10}]
#+END_SRC


** Suggestions

Notice that in the /suggest/ function call, the field and suggestion-prefix are *not* passed as a map, as unlike search, suggest calls are only supported over a single field.

**** Suggestions support for fields passed via /:suggest-fields/
From above, the fields `Album` and `Artist` have been marked to be indexed in a way so that we can ask for prefix-based suggestions.

#+BEGIN_SRC clojure :results output code :tangle dev/dev.clj :exports both
  (lucene/suggest index :Album "par"
                  {:hit->doc #(ld/document->map % :multi-fields [:Genre :Subgenre])
                   :fuzzy? false
                   :contexts ["Electronic"]})
#+END_SRC

#+RESULTS:
#+BEGIN_SRC clojure
[{:hit
  {:Number "140",
   :Year "1978",
   :Album "Parallel Lines",
   :Artist "Blondie",
   :Genre ["Electronic" "Rock"],
   :Subgenre ["New Wave" "Pop Rock" "Punk" "Disco"]},
  :score 1.0,
  :doc-id 139}]
#+END_SRC

We can ask for fuzzy matching when querying for suggestions.
#+BEGIN_SRC clojure :results output code :tangle dev/dev.clj :exports both
  (lucene/suggest index :Album "per"
                  {:hit->doc #(ld/document->map % :multi-fields [:Genre :Subgenre])
                   :fuzzy? true
                   :contexts ["Electronic"]})
#+END_SRC

#+RESULTS:
#+BEGIN_SRC clojure
[{:hit
  {:Number "140",
   :Year "1978",
   :Album "Parallel Lines",
   :Artist "Blondie",
   :Genre ["Electronic" "Rock"],
   :Subgenre ["New Wave" "Pop Rock" "Punk" "Disco"]},
  :score 2.0,
  :doc-id 139}
 {:hit
  {:Number "76",
   :Year "1984",
   :Album "Purple Rain",
   :Artist "Prince and the Revolution",
   :Genre ["Electronic" "Rock" "Funk / Soul" "Stage & Screen"],
   :Subgenre ["Pop Rock" "Funk" "Soundtrack" "Synth-pop"]},
  :score 2.0,
  :doc-id 75}]
#+END_SRC


**** Or, do a fuzzy search
#+BEGIN_SRC clojure :results output code m:tangle dev/dev.clj :exports both
  (lucene/search index {:Album "forever"}
                 {:hit->doc #(ld/document->map % :multi-fields [:Genre :Subgenre])
                  :fuzzy? true})
#+END_SRC

#+RESULTS:
#+BEGIN_SRC clojure
[{:hit
  {:Number "40",
   :Year "1967",
   :Album "Forever Changes",
   :Artist "Love",
   :Genre ["Rock"],
   :Subgenre ["Folk Rock" "Psychedelic Rock"]},
  :score 3.0850306,
  :doc-id 39}
 {:hit
  {:Number "132",
   :Year "1977",
   :Album "Saturday Night Fever: The Original Movie Sound Track",
   :Artist "Various Artists",
   :Genre ["Electronic" "�Stage & Screen"],
   :Subgenre ["Soundtrack" "�Disco"]},
  :score 0.95929563,
  :doc-id 131}]
#+END_SRC


** Sample Datasets
1. [[https://www.kaggle.com/notgibs/500-greatest-albums-of-all-time-rolling-stone][Albums - Kaggle]] - [[[file:test-resources/albumlist.csv][local]]]
2. Hand-created, real + fictional characters [[file:test-resources/sample-data.csv][here]]


** Additional notes
- Some minimal technical overview of Lucene internals for this project can be found [[file:doc/LuceneNotes.org][here]].


** License
Copyright © 2018-19 Ravindra R. Jaju

Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version.
